// script.js

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const messageDiv = document.getElementById('message');

// --- Configuration ---
// Your backend server URL. Make sure this matches the port your Node.js server is running on.
// const BACKEND_URL = 'https://95ee-2401-4900-1c73-6ae7-f440-e00f-26e2-ae4.ngrok-free.app';
const BACKEND_URL = 'http://localhost:3000'; // This will be updated with ngrok URL when testing publicly

// We'll set a fixed canvas size. The image from the backend will be scaled to fit.
const CANVAS_WIDTH = 500; // UPDATED from 400
const CANVAS_HEIGHT = 375; // UPDATED from 300

// Symbols for the shareable grid - UPDATED to use more widely supported colored circle emojis
const CORRECT_SYMBOL = 'ðŸŸ¢';   // Green circle for correct guess
const VERY_CLOSE_SYMBOL = 'ðŸŸ¡'; // Yellow circle for very close
const SOMEWHAT_CLOSE_SYMBOL = 'ðŸŸ '; // Orange circle for somewhat close
const NOT_CLOSE_SYMBOL = 'ðŸ”´';   // Red circle for not close
const UNUSED_SLOT_SYMBOL = 'âš«'; // Black circle for unused slots
const GAME_TITLE = 'Daily Pixel Reveal'; // Title for the shareable message

// --- Game State Variables ---
let currentImage = new Image(); // HTML Image element to hold the loaded image
let correctAnswer = "";         // This will now be the word generated by the LLM via the backend
let pixelationBlockSize = 25;   // Start highly pixelated (larger number = more pixelated)
const MIN_PIXELATION_BLOCK_SIZE = 1; // Minimum pixelation (fully clear image)
const PIXELATION_DECREMENT = 4;  // How much to reduce block size on each wrong guess (for 7 tries: 25 -> 21 -> 17 -> 13 -> 9 -> 5 -> 1)
let guessesRemaining = 7;      // Total attempts for the player
let currentGuessCount = 0;    // How many guesses made in current puzzle
let gameWon = false;          // Track if the current game was won
let guessesMadeHistory = [];  // Array to store history of guesses and their feedback

// For animation
let animationStartTime = null;
const ANIMATION_DURATION = 300; // milliseconds for blur transition

// --- HTML Element References ---
const guessInput = document.getElementById('guessInput');
const submitGuessBtn = document.getElementById('submitGuess');
// Get references to the spinner and text within the button
const submitButtonText = submitGuessBtn.querySelector('.button-text');
const submitButtonSpinner = submitGuessBtn.querySelector('.spinner');
const resetPuzzleBtn = document.getElementById('resetPuzzleBtn'); // New button reference

// New modal elements
const resultsModal = document.getElementById('resultsModal');
const modalTitle = document.getElementById('modalTitle'); // New reference for the modal title
const correctAnswerDisplay = document.getElementById('correctAnswerDisplay');
const shareGridDisplay = document.getElementById('shareGridDisplay');
const copyToClipboardBtn = document.getElementById('copyToClipboardBtn');
const closeModalBtn = document.getElementById('closeModalBtn');

// New: Reference for the guesses history list
const guessesList = document.getElementById('guessesList');

// Theme toggle elements
const themeToggleBtn = document.getElementById('themeToggle');
const sunIcon = document.getElementById('sunIcon');
const moonIcon = document.getElementById('moonIcon');

// Reference for the header date/time display (existing)
const currentDateTimeSpan = document.getElementById('currentDateTime');

// NEW: Reference for the footer date/time display
const currentDateTimeFooterSpan = document.getElementById('currentDateTimeFooter');

// NEW: References for How to Play modal elements
const howToPlayBtn = document.getElementById('howToPlayBtn');
const instructionsModal = document.getElementById('instructionsModal');
const closeInstructionsModalBtn = document.getElementById('closeInstructionsModalBtn');


// --- Core Functions ---

/**
 * Shows the loading spinner on the submit button.
 */
function showButtonLoading() {
    submitGuessBtn.disabled = true;
    guessInput.disabled = true;
    submitGuessBtn.classList.add('loading'); // Add class to show spinner
    submitGuessBtn.classList.add('opacity-70', 'cursor-not-allowed'); // Apply disabled visual styles
}

/**
 * Hides the loading spinner and resets the submit button.
 * Note: This only hides the spinner during active guessing.
 * Final disabling after game end (win/loss) is handled by handleSubmitGuess.
 */
function hideButtonLoading() {
    // Only re-enable if the game isn't already over
    if (guessesRemaining > 0 && !gameWon) {
        submitGuessBtn.disabled = false;
        guessInput.disabled = false;
    }
    submitGuessBtn.classList.remove('loading'); // Remove class to hide spinner
    submitGuessBtn.classList.remove('opacity-70', 'cursor-not-allowed'); // Remove disabled visual styles
    guessInput.focus(); // Keep focus on input
}


/**
 * Checks if the current date is different from the date the last puzzle was loaded.
 * This is crucial for making it a "daily" puzzle.
 * @returns {boolean} True if it's a new day, false otherwise.
 */
function isNewDay() {
    // Use UTC date string to match backend's daily puzzle logic
    const lastPuzzleDate = localStorage.getItem('lastPuzzleDate');
    const todayUtc = new Date().toISOString().slice(0, 10); //YYYY-MM-DD UTC
    return lastPuzzleDate !== todayUtc;
}

/**
 * Draws the current image onto the canvas, potentially with pixelation.
 * @param {number} currentBlockSize - The pixelation block size to use for this draw call.
 */
function drawImageOnCanvas(currentBlockSize) {
    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear previous drawing

    // Apply pixelation effect if currentBlockSize is greater than MIN_PIXELATION_BLOCK_SIZE
    if (currentBlockSize > MIN_PIXELATION_BLOCK_SIZE) {
        const effectiveBlockSize = Math.max(MIN_PIXELATION_BLOCK_SIZE, currentBlockSize);

        // Draw the image at a very small resolution to create the pixelated effect
        ctx.drawImage(currentImage, 0, 0, canvas.width / effectiveBlockSize, canvas.height / effectiveBlockSize);
        
        // Scale that tiny image back up to fill the canvas, disabling smoothing to keep pixels sharp
        ctx.msImageSmoothingEnabled = false; // For IE/Edge
        ctx.mozImageSmoothingEnabled = false; // For Firefox
        ctx.webkitImageSmoothingEnabled = false; // For Chrome/Safari
        ctx.imageSmoothingEnabled = false; // Standard

        ctx.drawImage(canvas, 0, 0, canvas.width / effectiveBlockSize, canvas.height / effectiveBlockSize,
                      0, 0, canvas.width, canvas.height);
    } else {
        // Draw the image normally (fully clear)
        ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    }
}

/**
 * Animates the pixelation change over a duration.
 * @param {number} startBlockSize - The pixelation block size at the start of the animation.
 * @param {number} endBlockSize - The target pixelation block size at the end of the animation.
 */
function animatePixelation(startBlockSize, endBlockSize) {
    animationStartTime = performance.now(); // Record the start time

    function step(currentTime) {
        const elapsed = currentTime - animationStartTime;
        const progress = Math.min(elapsed / ANIMATION_DURATION, 1); // Clamp progress between 0 and 1

        // Linear interpolation for pixelation block size
        const interpolatedBlockSize = startBlockSize + (endBlockSize - startBlockSize) * progress;

        // Ensure pixelation doesn't go below min or above max starting point
        pixelationBlockSize = Math.max(MIN_PIXELATION_BLOCK_SIZE, interpolatedBlockSize);

        drawImageOnCanvas(pixelationBlockSize); // Draw with the interpolated size

        if (progress < 1) {
            requestAnimationFrame(step); // Continue animation
        } else {
            // Animation finished, ensure final state is exactly the target
            pixelationBlockSize = endBlockSize;
            drawImageOnCanvas(pixelationBlockSize);
        }
    }

    requestAnimationFrame(step); // Start the animation loop
}


/**
 * Generates the shareable grid with Wordle-style emojis based on guess history.
 * @param {boolean} won - True if the game was won, false if lost.
 * @param {number} guessesTaken - The number of guesses the player made.
 * @returns {string} The formatted emoji grid string.
 */
function generateShareGrid(won, guessesTaken) {
    let grid = '';
    
    // Build the grid based on guessesMadeHistory
    for (let i = 0; i < 7; i++) { // Loop through all 7 potential guess slots
        if (i < guessesMadeHistory.length) { // If a guess was made for this slot
            const guess = guessesMadeHistory[i];
            if (guess.closeness === 'exact match') {
                grid += CORRECT_SYMBOL;
            } else if (guess.closeness && guess.closeness.includes('very close')) {
                grid += VERY_CLOSE_SYMBOL;
            } else if (guess.closeness && guess.closeness.includes('somewhat close')) {
                grid += SOMEWHAT_CLOSE_SYMBOL;
            } else { // 'not close' or 'error getting feedback'
                grid += NOT_CLOSE_SYMBOL;
            }
        } else { // Unused guess slot
            grid += UNUSED_SLOT_SYMBOL; // Use black circle for unused slots
        }
    }

    const summaryLine = won ? `Guessed in ${currentGuessCount}/7 reveals!` : `Couldn't reveal it.`;
    const shareText = `${GAME_TITLE}\n${summaryLine}\n\n${grid}\nReveal more daily: [Your Game URL Here - will replace later]`;
    return shareText;
}


/**
 * Displays the shareable results and provides a copy to clipboard button.
 * @param {string} shareText - The text to be shared.
 */
function displayShareResults(shareText) {
    // Populate modal content
    correctAnswerDisplay.textContent = correctAnswer; // Display the correct answer
    shareGridDisplay.textContent = shareText; // Display the shareable grid

    // Set modal title based on game outcome
    if (gameWon) {
        modalTitle.textContent = "Puzzle Completed!";
    } else {
        modalTitle.textContent = "Puzzle Failed!"; // Set "Puzzle Failed!" for a loss
    }

    // Set up copy to clipboard functionality for the modal button
    copyToClipboardBtn.onclick = () => {
        if (!navigator.clipboard || !navigator.clipboard.writeText) {
            const textArea = document.createElement("textarea");
            textArea.value = shareText;
            textArea.style.position = "fixed";
            textArea.style.opacity = "0";
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            try {
                document.execCommand('copy');
                messageDiv.textContent = 'Results copied to clipboard (fallback)!';
            } catch (err) {
                console.error('Fallback: Could not copy text: ', err);
                messageDiv.textContent = 'Failed to copy results. Please copy manually.';
            }
            document.body.removeChild(textArea);
        } else {
            navigator.clipboard.writeText(shareText).then(() => {
                messageDiv.textContent = 'Results copied to clipboard!';
            }).catch(err => {
                console.error('Could not copy text: ', err);
                messageDiv.textContent = 'Failed to copy results. Please copy manually.';
            });
        }
    };

    // Show the modal
    resultsModal.classList.remove('hidden');
    // The guess input and button are already disabled permanently on game end, so no change here.
}

/**
 * Hides the results modal.
 * This function no longer re-enables the guess button/input.
 * The disabling is now handled permanently on game end by handleSubmitGuess.
 */
function hideResultsModal() {
    resultsModal.classList.add('hidden');
    // The input and button will remain disabled if the game is over.
}

/**
 * NEW: Shows the instructions modal.
 */
function showInstructionsModal() {
    instructionsModal.classList.remove('hidden');
}

/**
 * NEW: Hides the instructions modal.
 */
function hideInstructionsModal() {
    instructionsModal.classList.add('hidden');
}

/**
 * Updates the "Your Guesses" list on the right side of the screen.
 * Now dynamically adds list items based on `guessesMadeHistory`.
 */
function updateGuessesListDisplay() {
    guessesList.innerHTML = ''; // Clear existing list items

    // Add list items for each guess made
    guessesMadeHistory.forEach((guess, index) => {
        const listItem = document.createElement('li');
        // Use flexbox for consistent alignment within each list item
        listItem.className = 'px-1.5 py-1 rounded-md flex justify-between items-center ' +
                            'overflow-hidden whitespace-nowrap text-ellipsis '; // Apply common styles

        // Apply different background colors based on closeness feedback
        if (guess.closeness === 'exact match') {
            listItem.classList.add('bg-green-200'); // Green for correct
            listItem.classList.add('dark:bg-green-300', 'dark:text-black'); // Bright green, black text for dark mode
        } else if (guess.closeness && guess.closeness.includes('very close')) {
            listItem.classList.add('bg-yellow-100'); // Light yellow for very close
            listItem.classList.add('dark:bg-yellow-200', 'dark:text-black'); // Bright yellow, black text for dark mode
        } else if (guess.closeness && guess.closeness.includes('somewhat close')) {
            listItem.classList.add('bg-orange-100'); // Light orange for somewhat close
            listItem.classList.add('dark:bg-orange-200', 'dark:text-black'); // Bright orange, black text for dark mode
        } else {
            listItem.classList.add('bg-red-100'); // Light red for not close / incorrect
            listItem.classList.add('dark:bg-red-200', 'dark:text-black'); // Bright red, black text for dark mode
        }

        // Create span for guess number and text (left aligned)
        const guessTextSpan = document.createElement('span');
        // Ensure the guess text is truncated if it's too long
        guessTextSpan.className = 'flex-shrink min-w-0'; 
        // Only display the guess text, without the closeness feedback
        guessTextSpan.textContent = `${index + 1}. ${guess.text}`;
        listItem.appendChild(guessTextSpan);

        guessesList.appendChild(listItem);
    });
}

/**
 * Fetches the daily puzzle details (image URL and AI-generated correct word) from your backend.
 * Prioritizes loading from localStorage if it's the same day,
 * otherwise fetches a new one from your backend.
 * @param {boolean} [forceNewPuzzle=false] - If true, tells the backend to generate a new puzzle regardless of caching.
 * @returns {Promise<{imageUrl: string, correctWord: string}|null>} A promise that resolves
 * with the puzzle data, or null if an error occurs.
 */
async function getDailyPuzzleData(forceNewPuzzle = false) {
    const todayUtc = new Date().toISOString().slice(0, 10);
    
    console.log("Fetching daily puzzle from backend for today (UTC):", todayUtc);
    messageDiv.textContent = "Loading today's puzzle...";
    showButtonLoading(); // Use the new loading function

    try {
        let fetchUrl = `${BACKEND_URL}/api/get-daily-word`;
        if (forceNewPuzzle) {
            fetchUrl += `?forceNew=true`; // Add query parameter to force new puzzle
        }

        const response = await fetch(fetchUrl, {
            headers: {
                'ngrok-skip-browser-warning': 'true' // Any value works
            }
        });

        if (!response.ok) {
            throw new Error(`Backend API error during word generation! Status: ${response.status} - ${response.statusText}`);
        }
        const data = await response.json();

        puzzleData = {
            imageUrl: data.imageUrl,
            correctWord: data.correctWord
        };

        // Store the new puzzle in localStorage, using the UTC date as the key for 'lastPuzzleDate'
        localStorage.setItem('lastPuzzleDate', todayUtc); // Store UTC date
        localStorage.setItem('dailyPuzzle', JSON.stringify(puzzleData));
        
        correctAnswer = puzzleData.correctWord; // Set the global correct answer

        // The message will be updated when currentImage.onload fires
        return puzzleData;

    } catch (error) {
        console.error("Error fetching daily puzzle from backend:", error);
        messageDiv.textContent = `Failed to load daily puzzle: ${error.message}. Please check backend server and API keys.`;
        // Keep controls disabled on critical error
        submitGuessBtn.disabled = true;
        guessInput.disabled = true;
        return null;
    } finally {
        hideButtonLoading(); // Ensure button state is reset after initial load attempt
    }
}

/**
 * Handles the user's guess submission, checks for correctness, and provides feedback.
 */
async function handleSubmitGuess() {
    const userGuess = guessInput.value.trim().toLowerCase();

    // --- Input Validation ---
    if (!userGuess) {
        messageDiv.textContent = "Please enter a guess!";
        return;
    }
    // Check for single word (no spaces)
    if (userGuess.includes(' ')) {
        messageDiv.textContent = "Please enter only a single word!";
        guessInput.value = ''; // Clear input
        return;
    }
    // Check for alphabetic characters only
    if (!/^[a-z]+$/.test(userGuess)) {
        messageDiv.textContent = "Please enter only alphabetic characters!";
        guessInput.value = ''; // Clear input
        return;
    }

    // --- DEBUG LOGS START ---
    console.log("--- New Guess Attempt ---");
    console.log("Current Guess Count (before increment):", currentGuessCount);
    console.log("Guesses Remaining (before decrement):", guessesRemaining);
    // --- DEBUG LOGS END ---

    // IMPORTANT: Check for game over BEFORE processing guess
    if (guessesRemaining <= 0 || gameWon) { // Added gameWon check
        messageDiv.textContent = "Game is already over! Please reset to play again.";
        submitGuessBtn.disabled = true;
        guessInput.disabled = true;
        hideButtonLoading(); // Ensure button is reset if this condition is met
        return;
    }

    currentGuessCount++;
    guessesRemaining--;

    // --- DEBUG LOGS START ---
    console.log("Current Guess Count (after increment):", currentGuessCount);
    console.log("Guesses Remaining (after decrement):", guessesRemaining);
    // --- DEBUG LOGS END ---

    // Check if the guess is directly correct
    if (userGuess === correctAnswer.toLowerCase()) {
        gameWon = true; // Set game won flag
        messageDiv.textContent = `ðŸŽ‰ Correct! You guessed "${correctAnswer}" in ${currentGuessCount} tries!`;
        // Store the correct guess with its feedback
        guessesMadeHistory.push({ text: userGuess, closeness: 'exact match' });
        updateGuessesListDisplay(); // Update list after correct guess
        
        // Directly set to min pixelation for winning reveal
        pixelationBlockSize = MIN_PIXELATION_BLOCK_SIZE; 
        drawImageOnCanvas(pixelationBlockSize); // Draw the final clear image
        
        submitGuessBtn.disabled = true; // Permanently disable on win
        guessInput.disabled = true;     // Permanently disable on win
        
        // --- Shareable results on WIN ---
        const shareText = generateShareGrid(gameWon, currentGuessCount);
        displayShareResults(shareText); // Show the modal here
        
        hideButtonLoading(); // Ensure button is reset on win
        return; // Game won, stop here
    }

    // If incorrect, get closeness feedback from the backend LLM
    // Temporarily disable controls and show loading indicator
    showButtonLoading();

    // Declare closenessResponse and closenessFeedback outside the try block
    let closenessResponse; 
    let closenessFeedback = "unknown"; // Initialize with a default value
    try {
        closenessResponse = await fetch(`${BACKEND_URL}/api/check-guess-closeness`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'ngrok-skip-browser-warning': 'true'
            },
            body: JSON.stringify({
                correctWord: correctAnswer,
                userGuess: userGuess
            })
        });

        if (!closenessResponse.ok) { 
            throw new Error(`Backend API error checking closeness! Status: ${closenessResponse.status}`);
        }
        const data = await closenessResponse.json();
        closenessFeedback = data.closeness; // Assign value here

        // Store the incorrect guess with its feedback
        guessesMadeHistory.push({ text: userGuess, closeness: closenessFeedback });
        updateGuessesListDisplay(); // Update list after incorrect guess

        // Display the feedback immediately after receiving it
        messageDiv.textContent = `Incorrect! Your guess was "${closenessFeedback}". Guesses left: ${guessesRemaining}`;

    } catch (error) {
        console.error("Error getting closeness feedback:", error);
        // Provide more specific feedback if closenessResponse exists but has an issue
        if (closenessResponse && closenessResponse.status) {
             messageDiv.textContent = `Incorrect! Error getting feedback (${closenessResponse.status}). Guesses left: ${guessesRemaining}`;
        } else {
             messageDiv.textContent = `Incorrect! Error getting feedback. Guesses left: ${guessesRemaining}`;
        }
        // If there's an error getting feedback, still record the guess as "unknown" closeness
        guessesMadeHistory.push({ text: userGuess, closeness: "error getting feedback" });
        updateGuessesListDisplay(); // Update list even on error
    } finally {
        // This block will always execute, ensuring the button is reset
        // However, if the game is over, we keep them disabled.
        hideButtonLoading(); // This now correctly respects the gameWon/guessesRemaining state.
    }

    // De-blur the image with animation
    const oldPixelationBlockSize = pixelationBlockSize; // Store current blur state
    const newPixelationBlockSize = Math.max(MIN_PIXELATION_BLOCK_SIZE, pixelationBlockSize - PIXELATION_DECREMENT);
    
    // Animate the transition
    animatePixelation(oldPixelationBlockSize, newPixelationBlockSize);


    // Check if game is over (lost)
    if (guessesRemaining <= 0 && !gameWon) { // Ensure it's not already won
        gameWon = false; // Set game lost flag explicitly
        console.log("GAME OVER CONDITION MET: Guesses Remaining is 0 or less."); // DEBUG
        messageDiv.textContent = `Game Over! The word was "${correctAnswer}".`;
        // Ensure image is fully revealed on loss
        pixelationBlockSize = MIN_PIXELATION_BLOCK_SIZE; 
        drawImageOnCanvas(pixelationBlockSize); // Draw the final clear image
        submitGuessBtn.disabled = true; // Permanently disable on loss
        guessInput.disabled = true;     // Permanently disable on loss

        // --- Shareable results on LOSS ---
        const shareText = generateShareGrid(gameWon, currentGuessCount);
        displayShareResults(shareText); // Show the modal here
        
        hideButtonLoading(); // Ensure button is reset on loss
    }

    guessInput.value = ''; // Clear input after guess
}

/**
 * Resets the game state and initiates loading a new puzzle.
 * @param {boolean} [forceNew=false] - If true, forces the game to fetch a brand new puzzle from the backend.
 */
function resetPuzzle(forceNew = false) {
    // Clear localStorage for the puzzle and last puzzle date
    // These are cleared so that the frontend doesn't serve an old puzzle from its cache,
    // ensuring it always asks the backend for the latest (or forced new) puzzle.
    localStorage.removeItem('lastPuzzleDate'); // Clear the UTC date
    localStorage.removeItem('dailyPuzzle'); // Clear the puzzle data

    // Reset game state variables
    pixelationBlockSize = 25;
    guessesRemaining = 7; // Reset to 7
    currentGuessCount = 0;
    gameWon = false;
    guessesMadeHistory = []; // Clear guess history

    // Hide the results modal if it's open
    hideResultsModal();
    // Hide instructions modal if it's open
    hideInstructionsModal();
    
    // Clear any existing share results div that might have been dynamically created
    const existingShareDiv = document.querySelector('.share-results');
    if (existingShareDiv && existingShareDiv.parentElement === document.body) { // Check if it's the old, directly appended one
        existingShareDiv.remove();
    }

    // Re-enable input and button ONLY when resetting to a new game
    submitGuessBtn.disabled = false;
    guessInput.disabled = false;
    guessInput.focus();

    // Update the guesses list display to be completely empty
    updateGuessesListDisplay(); 

    // Pass the forceNew flag to initGame
    initGame(forceNew);
    guessInput.value = ''; // Clear input field
}

/**
 * Toggles the dark mode class on the document element and updates localStorage.
 * Also toggles the visibility of the sun and moon icons.
 */
function toggleTheme() {
    const isDarkMode = document.documentElement.classList.toggle('dark');
    localStorage.theme = isDarkMode ? 'dark' : 'light'; // Persist preference

    // Toggle icon visibility
    if (isDarkMode) {
        sunIcon.classList.add('hidden');
        moonIcon.classList.remove('hidden');
    } else {
        sunIcon.classList.remove('hidden');
        moonIcon.classList.add('hidden');
    }
}

/**
 * Updates the current date and time displayed in the header.
 */
function updateDateTimeDisplay() {
    if (currentDateTimeSpan) { // Check if the element exists
        const now = new Date();
        const options = { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric', 
            hour: '2-digit', 
            minute: '2-digit', 
            second: '2-digit', 
            hour12: true 
        };
        currentDateTimeSpan.textContent = now.toLocaleString('en-US', options);
    }
}

/**
 * Updates the current date and time displayed in the footer.
 */
function updateFooterDateTimeDisplay() {
    if (currentDateTimeFooterSpan) { // Check if the element exists
        const now = new Date();
        const options = { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric', 
            hour: '2-digit', 
            minute: '2-digit', 
            hour12: true 
        };
        currentDateTimeFooterSpan.textContent = now.toLocaleString('en-US', options);
    }
}

/**
 * Initializes the game: gets the daily puzzle data and loads the image.
 * @param {boolean} [forceNewPuzzle=false] - If true, forces the backend to generate a new puzzle.
 */
async function initGame(forceNewPuzzle = false) {
    // Set canvas dimensions
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    // --- IMPORTANT: Remove existing event listeners before adding new ones ---
    // This part is crucial for preventing multiple listeners from stacking
    // when initGame is called multiple times (e.g., on reset).
    if (submitGuessBtn) {
        submitGuessBtn.removeEventListener('click', handleSubmitGuess);
    }
    if (guessInput) {
        // We need a named function reference for keypress to remove it
        if (guessInput._keypressHandler) { // Check if we stored the handler
            guessInput.removeEventListener('keypress', guessInput._keypressHandler);
        }
    }
    if (resetPuzzleBtn) {
        // We need a named function reference for reset click to remove it
        if (resetPuzzleBtn._resetClickHandler) { // Check if we stored the handler
            resetPuzzleBtn.removeEventListener('click', resetPuzzleBtn._resetClickHandler);
        }
    }
    if (closeModalBtn) {
        closeModalBtn.removeEventListener('click', hideResultsModal);
    }
    if (resultsModal) {
        // We need a named function reference for modal overlay click to remove it
        if (resultsModal._overlayClickHandler) { // Check if we stored the handler
            resultsModal.removeEventListener('click', resultsModal._overlayClickHandler);
        }
    }
    // Remove existing theme toggle listener to prevent stacking
    if (themeToggleBtn) {
        themeToggleBtn.removeEventListener('click', toggleTheme);
    }
    // NEW: Remove existing instructions modal listeners
    if (howToPlayBtn) {
        howToPlayBtn.removeEventListener('click', showInstructionsModal);
    }
    if (closeInstructionsModalBtn) {
        closeInstructionsModalBtn.removeEventListener('click', hideInstructionsModal);
    }
    if (instructionsModal) {
        if (instructionsModal._overlayClickHandler) {
            instructionsModal.removeEventListener('click', instructionsModal._overlayClickHandler);
        }
    }


    // --- Add event listeners ---
    if (submitGuessBtn) {
        submitGuessBtn.addEventListener('click', handleSubmitGuess);
    }
    if (guessInput) {
        const handleGuessKeyPress = (event) => {
            if (event.key === 'Enter') {
                handleSubmitGuess();
            }
        };
        guessInput.addEventListener('keypress', handleGuessKeyPress);
        guessInput._keypressHandler = handleGuessKeyPress; // Store reference for removal
    }
    if (resetPuzzleBtn) {
        const handleResetClick = () => resetPuzzle(true);
        resetPuzzleBtn.addEventListener('click', handleResetClick);
        resetPuzzleBtn._resetClickHandler = handleResetClick; // Store reference for removal
    }
    if (closeModalBtn) {
        closeModalBtn.addEventListener('click', hideResultsModal);
    }
    if (resultsModal) {
        const handleModalOverlayClick = (event) => {
            if (event.target === resultsModal) { 
                hideResultsModal();
            }
        };
        resultsModal.addEventListener('click', handleModalOverlayClick);
        resultsModal._overlayClickHandler = handleModalOverlayClick; // Store reference for removal
    }
    // Add theme toggle listener
    if (themeToggleBtn) {
        themeToggleBtn.addEventListener('click', toggleTheme);
    }
    // NEW: Add event listeners for How to Play modal
    if (howToPlayBtn) {
        howToPlayBtn.addEventListener('click', showInstructionsModal);
    }
    if (closeInstructionsModalBtn) {
        closeInstructionsModalBtn.addEventListener('click', hideInstructionsModal);
    }
    if (instructionsModal) {
        const handleInstructionsOverlayClick = (event) => {
            if (event.target === instructionsModal) {
                hideInstructionsModal();
            }
        };
        instructionsModal.addEventListener('click', handleInstructionsOverlayClick);
        instructionsModal._overlayClickHandler = handleInstructionsOverlayClick;
    }


    // --- Initial Theme Application (Moved here from index.html) ---
    // Check localStorage for a saved theme preference, otherwise check system preference
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
        // Ensure icon is correct on initial load
        if (sunIcon && moonIcon) {
            sunIcon.classList.add('hidden');
            moonIcon.classList.remove('hidden');
        }
    } else {
        document.documentElement.classList.remove('dark');
        // Ensure icon is correct on initial load
        if (sunIcon && moonIcon) {
            sunIcon.classList.remove('hidden');
            moonIcon.classList.add('hidden');
        }
    }


    // Initialize the guesses list display (will be empty initially)
    updateGuessesListDisplay(); 

    // Update date and time immediately and set interval for updates for both header and footer
    updateDateTimeDisplay(); // For the header (if still present)
    updateFooterDateTimeDisplay(); // For the new footer date/time
    setInterval(updateDateTimeDisplay, 1000); // Update header every second
    setInterval(updateFooterDateTimeDisplay, 1000); // Update footer every second

    // Pass forceNewPuzzle to getDailyPuzzleData
    const puzzleData = await getDailyPuzzleData(forceNewPuzzle);

    if (puzzleData) {
        currentImage.onload = () => {
            drawImageOnCanvas(pixelationBlockSize); // Draw initial pixelated image
            messageDiv.textContent = `Guesses left: ${guessesRemaining}`; // Update message after image loads
        };
        currentImage.onerror = () => {
            messageDiv.textContent = "Error loading image from URL. Please try refreshing.";
            console.error("Image loading error for URL:", puzzleData.imageUrl);
            submitGuessBtn.disabled = true; // Disable controls on image load failure
            guessInput.disabled = true;
        };
        currentImage.src = puzzleData.imageUrl; // Start loading the image
    } else {
        // Error message already set by getDailyPuzzleData
        console.error("Could not retrieve valid puzzle data.");
    }
}


// --- Initial Game Start ---
// We call initGame to start the whole process when the script loads.
initGame();
